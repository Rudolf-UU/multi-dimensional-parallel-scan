# Multidimensional Parallel Scans for Multi-Core CPUs

In this repository several parallel scan algorithms are introduced, which are able to handle multidimensional data structures on multi-core CPUs. Many parallel scan algorithms have been introduced in the past years by several researchers, but most of them focus on just one-dimensional input sequences. The algorithms in this repository can adaptively change the number of cores working on the data during execution time and some are able to achieve zero overhead compared to the sequential scan when executed on a single core. The main algorithm (assisting column-wise chained scan) is not only able to match the above two properties on multidimensional data sequences, but also matches the performance of the 'adaptive chained scan' presented in the 'zero-overhead parallel scans for multi-core CPUs' (https://doi.org/10.1145/3649169.3649248) on one-dimensional data sequences. 

The general code setup and benchmarks within this repository are implemented using the original [zero-overhead-parallel-scan](https://github.com/ivogabe/zero-overhead-parallel-scans) repository. Furthermore, the scan algorithms are making use of this [work-assisting scheduler](https://github.com/ivogabe/workassisting), but could also be applied with other schedulers.

## Instructions
To run the benchmarks, the Rust compiler and cargo need to be installed. Furthermore gnuplot needs to be installed, as the benchmark code automatically generates charts of the results. The benchmarks can be run with `cargo run`. The generated charts and tables are placed in `./results`. Depending on the processor, it may be needed to tune `AFFINITY_MAPPING` in `./src/utils/thread_pinning.rs`. This specifies the order in which the cores of the processor are used.

The program will ask if a sequential implementation in C++ should be enabled. This requires Linux, clang++ and cmake. When enabled, it will automatically build and execute a reference sequential C++ implementation.